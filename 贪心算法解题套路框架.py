"""
「问题一」
现在有两种钞票，面额分为为 1 元和 100 元，每种钞票的数量无限，但现在你只能选择 10 张，请问你应该如何选择，才能使得总金额最大？
按照算法思维，这个问题的本质是做 10 次选择，每次选择有两种可能，分别是 1 元和 100 元，一共有 2^10 种可能的选择。

所以你心里首先应该出现一棵高度为 10 的二叉树来穷举所有可行解，遍历这些可行解，然后可以得到最优解。

// 定义：做 n 次选择，返回可以获得的最大金额
int findMax(int n) {
    if (n == 0) return 0;
    
    // 这次选择 1 元，然后递归求解剩下的 n - 1 次选择的最大值
    int result1 = 1 + findMax(n - 1);
    // 这次选择 100 元，然后递归求解剩下的 n - 1 次选择的最大值
    int result2 = 100 + findMax(n - 1);

    // 返回两种选择中的最大值
    return Math.max(result1, result2);
}

// 优化一、没必要对两种选择进行比较了
int findMax(int n) {
    if (n == 0) return 0;
    int result = 100 + findMax(n - 1);
    return result;
}

// 优化二、递归改为迭代
int findMax(int n) {
    int result = 0;
    for (int i = 0; i < n; i++) {
        result += 100;
    }
    return result;
}

// 优化三、直接计算结果就行了
int findMax(int n) {
    return 100 * n;
}

「问题二」
现在有两种钞票，面额分别为 1 元和 100 元，每种钞票的数量无限。
现在给你一个目标金额 amount，请问你最少需要多少张钞票才能凑出这个金额？
"""


"""
贪心选择性质就是说能够通过局部最优解直接推导出全局最优解。

对于问题一，局部最优解就是每次都选择 100 元，因为 100 > 1；
对于问题二，局部最优解也是每次都选择 100 元，因为每张面额尽可能大，所需的钞票数量就能尽可能少。

问题一中每一次选择的局部最优解组合起来就是全局最优解，
问题二中不是。虽然每次选择 100 元是局部最优解，但想凑出 3 元，只能选择 3 张 1 元，局部最优解不一定能构成全局最优解。
问题二的场景，不符合贪心选择性质，所以不能用贪心算法，只能穷举所有可行解，才能计算出最优解。
"""



# 5. 跳跃游戏 | 力扣 | LeetCode |  🟠
# 输入：nums = [2,3,1,1,4]
# 输出：true
# 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
"""
朴素思想：
    假设 N 为 nums 的长度，这道题相当于做 N 次选择，每次选择有 nums[i] 种选项，
    想要穷举所有的跳跃路径，就是一棵高度为 N 的多叉树，每个节点有 【至多】nums[i] 个子节点：

贪心思想：
    站在 nums[i] = 3 的位置，你可以跳到 i+1, i+2, i+3 三个位置，此时你真的需要分别跳过去，然后递归求解子问题 dp(i+1), dp(i+2), dp(i+3)，最后通过子问题的答案来决定 dp(i) 的结果吗？
    其实不用的，i+1, i+2, i+3 三个候选项，它们谁能走得最远，你就选谁，准没错。
    具体来说，i+1 能走到的最远距离是 i+1+nums[i+1]，i+2 能走到的最远距离是 i+2+nums[i+2]，i+3 能走到的最远距离是 i+3+nums[i+3]，你看看谁最大，就选谁。
"""

class Solution:
    def canJump(self, nums: List[int]) -> bool:
        n = len(nums)
        farthest = 0
        for i in range(n - 1):
            # 不断计算能跳到的最远距离
            farthest = max(farthest, i + nums[i])
            # 不可能跳到当前位置
            if farthest <= i:
                return False
        return farthest >= n - 1
    


# 45. 跳跃游戏 II | 力扣 | LeetCode |  🟠
# 输入: nums = [2,3,1,1,4]
# 输出: 2
# 解释: 跳到最后一个位置的最小跳跃数是 2。
#      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。

"""
朴素思想：
    动态回归暴力穷举

外层：位置 i 从 0 到 n-1，最多执行 n 次调用
内层：从 i 位置最多跳 nums[i] 步

最坏情况是：每个位置都能跳到后面所有位置，比如 nums = [n, n, n, ..., n]
那么从位置 i，你可能对 i+1, i+2, ..., n-1 全部递归调用（如果还没被记忆化）

即：
总的调用次数≤∑i=0,n−1 (n−i) = n(n+1)/2=O(n^2)
"""
class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        # 因为从 0 跳到 n - 1 最多 n - 1 步，所以设置为n，相当于inf
        memo = [n] * n
        return self.dp(nums, 0, memo)
    # 定义：从索引 p 跳到最后一格，至少需要 dp(nums, p) 步
    def dp(self, nums, p: int, memo):
        n = len(nums)
        # base case
        if p >= n - 1:
            return 0
        if memo[p] != n:
            return memo[p]
        
        # 你可以选择跳 1 步，2 步...
        for i in range(1, nums[p] + 1):
            subProblem = self.dp(nums, p + i, memo)
            memo[p] = min(memo[p], subProblem + 1)
        return memo[p]


"""
不需要真的递归穷举出所有选择的具体结果来比较求最值，而只需要每次选择那个最有潜力的局部最优解，最终就能得到全局最优解。

思想：按“层”往前推进（BFS 的数组版）
    把每个下标 i 看成一个节点；从 i 能跳到的所有 j ∈ [i+1, i+nums[i]] 是边。
    我们要到达末尾，用 最少跳数。BFS 的性质：第一次到达某点一定是最少步数的那一层。
    我们不建图不排队，用两个边界来“模拟”层：
    end：当前这一跳（当前层）能覆盖到的最右端。
    farthest：在扫描当前层的所有点后，**下一跳（下一层）**能覆盖到的最右端。
    当我们把当前层的点都扫完了（i == end），说明必须 跳一次 才能继续往前，这时把 end 更新成刚才统计到的 farthest，层数（jumps）+1。

🧠 为什么不会漏掉“下下步”的情况？

举例：[2, 5, 3, 1, 1, 1, 1]

第 1 层（起点 0）能到 [1,2]，所以 end=2，jumps=1。

扫描层 [1,2]：

从 1 可以到 [2,3,4,5,6]，所以 farthest=6。

从 2 可以到 [3,4,5]，也在里面。

所以整个第 2 层覆盖到了 6（终点），jumps=2。

👉 注意：虽然算法“没有明确选择 0→1→6”，但它在 扫描整层 时已经把 1 的扩展考虑进来了。等扫描到 i==end==2，它更新 end=6，意味着：下一跳直接能到终点。
这等价于 BFS 已经找到了从 0 出发的 2 步路径。

所以 下下步、下下下步的可能性，都会在相应的层扫描时体现出来，不会漏。
"""

"""
BFS

层0（起点）:
  [0]
   能到 → {1, 2}

层1:
  [1, 2]
   1 能到 → {2,3,4,5,6}
   2 能到 → {3,4,5}
   合并去重 → {2,3,4,5,6}

  ✨ 第一次覆盖到 6 → 最少跳数 = 2


"""
def jump(nums):
    n = len(nums)
    end = 0          # 当前层的右边界
    farthest = 0     # 下一层的最远右边界
    jumps = 0        # 已用的跳数（层数）

    # 只遍历到 n-2：因为只要能“覆盖”最后一个下标就行，不需要从最后一个再往后扩展
    for i in range(n - 1):
        # 在当前层里，看看哪个点能把下一层推得最远
        farthest = max(farthest, i + nums[i])

        # 一旦扫描到当前层的边界，必须“落地”跳一下，进入下一层
        if i == end:
            jumps += 1
            end = farthest
            # （可选早停）如果下一层已经覆盖到或超过末尾，可以提前结束
            if end >= n - 1:
                jumps
    return -1
