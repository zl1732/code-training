===============================================================
【 bit_length() —— 二进制位数 】
===============================================================
1. 作用：
   返回一个正整数的二进制表示需要多少位（不包含符号位）。

2. 示例：
   5  的二进制是  101    → bit_length = 3
   8  的二进制是 1000    → bit_length = 4
   15 的二进制是 1111    → bit_length = 4

3. 直觉：
   bit_length 告诉你 “最高位的 1 在哪一位”。

4. 用处：
   - 快速判断数字处于哪个 “2 的幂区间”
   - 计算层级（例如完全二叉树的层数）
   - 与位运算搭配使用

5. 优点：
   - 纯整数操作 → 没有浮点误差
   - 比 log2 快
   - 语义非常清晰：看二进制结构


===============================================================
【 << （左移）—— 快速计算 2 的幂 】
===============================================================
1. 原理：
   (1 << k) = 把二进制的 1 左移 k 位
            = 2^k

2. 示例：
   1 << 0 = 1       → 2^0
   1 << 1 = 2       → 2^1
   1 << 2 = 4       → 2^2
   1 << 3 = 8       → 2^3
   1 << 4 = 16      → 2^4

3. 用途：
   - 构造 2 的幂
   - 构造 bitmask（如 (1<<k)-1 得到 k 个低位全是 1）
   - 各种需要“按位对齐”的场景（树层级、分组等）

4. 为什么好用：
   - 快
   - 无误差
   - 用整数操作表示数学上的 2^k，直观且安全


===============================================================
【 log2(x) —— 以 2 为底的对数 】
===============================================================
1. 含义：
   log₂(x) 的意思是 “2 的多少次方等于 x？”

2. 示例：
   log₂(8)  = 3
   log₂(16) = 4
   log₂(20) ≈ 4.32

3. 数学解释：
   如果 x 在区间 2^k ~ 2^(k+1)-1，
   则 log₂(x) ∈ [k , k+1)

4. 用途：
   - 纯数学运算（指数、概率、熵等）
   - 浮点范围内的估算

5. 缺点：
   - 使用浮点数 → 有精度误差
   - 有时不能可靠地判断“最高位在哪”
   - 在整数算法里不如 bit_length 稳定


===============================================================
【 三者关系总结 】
===============================================================
1. bit_length() 和 log2(x) 都与二进制位相关：
   - bit_length 直接告诉你位数（整数）
   - log2(x) 的整数部分也反映最高位所在位置

2. 但：
   bit_length      —— 精确、快速、推荐
   log2            —— 浮点、有误差、不适合层判断

3. 左移 <<：
   - 1 << k = 2^k
   - 是构造 2 的幂最稳定最推荐的方法

4. 当你要处理：
   - 层、深度、2 的幂区间 → 用 bit_length 或 <<
   - 纯数学对数 → 用 log2

===============================================================
【 最简单的统一例子（x = 20）】
===============================================================
20 的二进制是 10100 → bit_length = 5
它落在区间 2^4 ~ 2^5-1 中 → 对应最高位指数 = 4
log₂(20) ≈ 4.32 → 整数部分仍是 4
1 << 4 = 16 → 构造出与最高位相同的权重

三者完美一致：

   bit_length → 5（意味着最高位指数是 4）
   <<         → 1 << 4 = 16
   log2       → floor(log2(20)) = 4


===============================================================
【 背诵版（极简）】
===============================================================
bit_length       → 二进制位数（最可靠）
1 << k           → 2^k（最快）
log2             → 浮点对数（有误差）
===============================================================
