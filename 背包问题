
# 1. 通用的 0-1 背包问题
# 概念区别：
# 0-1 背包	每个物品只能用 0 或 1 次
# 完全背包	每个物品可以无限次使用#

"""
背包问题的 dp 数组定义

dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]。

比如说，如果 dp[3][5] = 6，其含义为：对于给定的一系列物品中，若只从前 3 个物品中选择，当背包容量为 5 时，最多可以装下的价值为 6。

根据这个定义，我们想求的最终答案就是 dp[N][W]。base case 就是 dp[0][..] = dp[..][0] = 0，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。
"""


# int[][] dp[N+1][W+1]
# dp[0][..] = 0
# dp[..][0] = 0

# for i in [1..N]:
#     for w in [1..W]:
#         dp[i][w] = max(
#             把物品 i 装进背包,
#             不把物品 i 装进背包
#         )
# return dp[N][W]



# for i in [1..N]:
#     for w in [1..W]:
#         dp[i][w] = max(
#             dp[i-1][w],
#             dp[i-1][w - wt[i-1]] + val[i-1]
#         )
# return dp[N][W]



# dp[i][w] 表示：对于前 i 个物品（从 1 开始计数），当前背包的容量为 w 时，这种情况下可以装下的最大价值是 dp[i][w]。
def knapsack(W: int, wt: List[int], val: List[int]) -> int:
    N = len(wt)
    # base case 已初始化
    dp = [[0] * (W + 1) for _ in range(N + 1)]
    for i in range(1, N + 1):
        for w in range(1, W + 1):
            # 背包容量还没有第i个物品所需容量大
            if w - wt[i-1] < 0:
                # 这种情况下只能选择不装入背包
                dp[i][w] = dp[i - 1][w]
            else:
                # 装入或者不装入背包，择优
                dp[i][w] = max(
                    dp[i - 1][w - wt[i-1]] + val[i-1], 
                    dp[i - 1][w]
                )
    return dp[N][W]


# 2. 子集背包问题
"""力扣第 416 题「分割等和子集」：
输入一个只包含正整数的非空数组 nums，请你写一个算法，判断这个数组是否可以被分割成两个子集，使得两个子集的元素和相等。

先对集合求和，得出 sum，把问题转化为背包问题：
给一个可装载重量为 sum / 2 的背包和 N 个物品，每个物品的重量为 nums[i]。现在让你装物品，是否存在一种装法，能够恰好将背包装满？

第二步要明确 dp 数组的定义。
dp[i][j] = x 表示，对于前 i 个物品（i 从 1 开始计数），当前背包的容量为 j 时，若 x 为 true，则说明可以恰好将背包装满，若 x 为 false，则说明不能恰好将背包装满。
📢注意存的是 True、False

base case 就是 dp[..][0] = true 和 dp[0][..] = false，因为背包没有空间的时候，就相当于装满了，而当没有物品可选择的时候，肯定没办法装满背包。

如果不把 nums[i] 算入子集，或者说你不把这第 i 个物品装入背包，那么是否能够恰好装满背包，取决于上一个状态 dp[i-1][j]，继承之前的结果。

如果把 nums[i] 算入子集，或者说你把这第 i 个物品装入了背包，那么是否能够恰好装满背包，取决于状态 dp[i-1][j-nums[i-1]]。
"""
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        total_sum = sum(nums)
        # 和为奇数时，不可能划分成两个和相等的集合
        if total_sum % 2 != 0:
            return False
        n = len(nums)
        target = total_sum // 2
        dp = [[False] * (target + 1) for _ in range(n + 1)]
        # base case
        for i in range(n + 1):
            dp[i][0] = True

        for i in range(1, n + 1):
            for j in range(1, target + 1):
                if j - nums[i - 1] < 0:
                    # 背包容量不足，不能装入第 i 个物品
                    dp[i][j] = dp[i - 1][j]
                else:
                    # 装入或不装入背包
                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]
        
        return dp[n][target]
    
"""
注意到 dp[i][j] 都是通过上一行 dp[i-1][..] 转移过来的，之前的数据都不会再使用了。

所以，我们可以参照 
对动态规划进行降维打击，将二维 dp 数组压缩为一维，节约空间复杂度：
"""
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        sumn = 0
        for num in nums: 
            sumn += num
            
        # 和为奇数时，不可能划分成两个和相等的集合
        if sumn % 2 != 0: 
            return False
        
        n = len(nums)
        sumn = sumn // 2
        dp = [False] * (sumn + 1)
        
        # base case
        dp[0] = True

        for i in range(0, n):
            for j in range(sumn, -1, -1):
                if j - nums[i] >= 0:
                    dp[j] = dp[j] or dp[j - nums[i]]
        
        return dp[sumn]
    
    
## 完全背包问题
# 可以重复用同一个元素
"""
518. 零钱兑换 II | 力扣 | LeetCode |  🟠
给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。
请你计算并返回可以凑成总金额的硬币组合数。
"""

"""
如果你不把这第 i 个物品装入背包，也就是说你不使用 coins[i-1] 这个面值的硬币，那么凑出面额 j 的方法数 dp[i][j] 应该等于 dp[i-1][j]，继承之前的结果。

如果你把这第 i 个物品装入了背包，也就是说你使用 coins[i-1] 这个面值的硬币，那么 dp[i][j] 应该等于 dp[i][j-coins[i-1]]。

dp[i][j-coins[i-1]]:
想用面值为 2 的硬币凑出金额 5，那么如果你知道了凑出金额 3 的方法，再加上一枚面额为 2 的硬币，就可以凑出 5 了

综上就是两种选择，而我们想求的 dp[i][j] 是「共有多少种凑法」，所以 dp[i][j] 的值应该是以上两种选择的结果之和：
dp[i][j] = dp[i - 1][j] + dp[i][j-coins[i-1]];
"""


"""
使用完全背包思路：

dp[i][j] = 使用前 i 个硬币，凑出金额 j 的组合数
注意事项：
    i 从 0 到 n，表示前 i 个硬币（第 i 个是 coins[i-1]）
    j 从 0 到 amount，表示金额

✅ 状态转移方程讲解（关键）
dp[i][j] = dp[i-1][j] + dp[i][j - coins[i-1]]
我自己理解： dp[i-1][j]的意思是不用新的（第i个）硬币，继续用前面的硬币拼出j的这部分解法
           dp[i][j - coins[i-1]] 加了新的硬币i，但是j - coins[i-1]的意思：新硬币面值coins[i-1]
           即 dp[i][目标总额 - 新硬币面值]，即 dp[i-1][目标总额 - 新硬币面值] ❌❌ 这是错的 ❌❌

🧠 🧠 🧠 🧠 🧠 
✅ 正确理解 dp[i][j - coins[i-1]] 是：
    允许在构造 [0, j - coins[i-1]] 这个金额的过程中使用 coins[i-1]”
    dp[i][j - coins[i-1]] 是允许 coins[i-1] 在整个构造过程中重复出现的
    它可能已经用了这个硬币，现在又再用一枚来构造 j

❌ 而 dp[i-1][j - coins[i-1]] 的含义是：
    在[0, j - coins[i-1]], 没用 coins[i-1]，直到这次才用一次
    所以这是 0-1 背包的行为：只允许 coins[i-1] 出现一次（当前这次）

    

✅ 你总结得非常好，我把你的原话稍作润色，供你保存：
    原来我误以为 dp[i][j - coins[i-1]] 是“我刚刚加了一个 coins[i-1]”，
    但其实它更重要的含义是：“我在构造 j - coins[i-1] 的过程中就可以多次使用 coins[i-1]，而不是只在最后加一次”。
    所以 dp[i][j - coins[i-1]] 是允许 coins[i-1] 出现在整个构造过程中任意位置的；
    而 dp[i-1][j - coins[i-1]] 才是那种“前面完全不准用 coins[i-1]，直到这次才用一次”的行为，这才是 0-1 背包的含义。


🧠 一个直觉图示：
以 coins = [1, 2]，amount = 4 为例：
    dp[1][4] 表示：用前 1 个硬币（也就是只用 1 元）凑出 4：
        可以：1+1+1+1，所以 dp[1][4] = 1
    dp[2][4] 表示：用前 2 个硬币（1 元和 2 元）凑出 4：
        不用 2 元 → dp[1][4] = 1
        用 2 元 → dp[2][2] = 2（2+2 或 1+1+2）
→ 所以 dp[2][4] = dp[1][4] + dp[2][2] = 1 + 2 = 3


dp[1][6] = dp[0][6] + dp[1][4]
        = 0 + dp[1][4]
              ↳ = dp[0][4] + dp[1][2]
                     ↳ = dp[0][2] + dp[1][0]
                            ↳ = dp[0][0] = 1

你从 dp[1][0] 一路“递推”过来，每次都是加一个 2，其实就等于你在考虑加1个、2个、3个硬币！

✅ 所以只需要加一次的原因：
    每个子状态会“滚动地”把前面的情况一层层推过来，等效于穷举了所有用 n 个当前硬币的情况！

你在更新 dp[i][j] 的时候，加了 dp[i][j - coin]，而这个 dp[i][j - coin] 本身已经包括：
    用了 1 个 coin 的组合
    用了 2 个 coin 的组合
    用了更多 coin 的组合…

"""

"""
✅ 所以：
dp[i][j - coins[i-1]]

→ 是：你想用硬币 coins[i-1] 来构造金额 j，所以你去看在已经凑出了 j - coins[i-1] 的所有组合，再加一个 coins[i-1] 就可以构成 j

    注意：你依然在第 i 行，说明你仍然可以继续用这个硬币（无限使用）

❌ 而 dp[i-1][j - coins[i-1]] 是什么意思？

→ 是：用前 i-1 个硬币凑出金额 j - coins[i-1] 的组合数

    然后你再加上一个 coins[i-1]，组成金额 j

    这等价于“0-1 背包”，因为你只用一次 coins[i-1]（下一次你不能再取了）
"""