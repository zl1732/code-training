
# nH, nL                # Heavy 和 Light 坦克数量
# hpH, hpL              # 每辆 Heavy / Light 坦克的血量
# atkH, atkL            # 每辆 Heavy / Light 坦克的攻击力
# dmgH, dmgL            # 你对 Heavy / Light 坦克的单次伤害


from math import ceil

def min_total_damage(nH, nL, hpH, hpL, atkH, atkL, dmgH, dmgL):
    # 每种敌人击杀所需的回合数
    pH = ceil(hpH / dmgH)
    pL = ceil(hpL / dmgL)

    INF = 10**18
    dp = [[INF] * (nL + 1) for _ in range(nH + 1)]
    dp[0][0] = 0

    for i in range(nH + 1):
        for j in range(nL + 1):
            if dp[i][j] == INF:
                continue
            time = i * pH + j * pL
            if i < nH:
                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + atkH * (time + pH))
            if j < nL:
                dp[i][j + 1] = min(dp[i][j + 1], dp[i][j] + atkL * (time + pL))
    return dp[nH][nL]


print("Test1:", min_total_damage(2, 3, 100, 50, 20, 10, 30, 50))
print("Test2:", min_total_damage(2, 2, 150, 40, 40, 10, 30, 40))
print("Test3:", min_total_damage(3, 3, 120, 60, 10, 25, 30, 50))
print("Test4:", min_total_damage(2, 3, 100, 50, 20, 10, 30, 1000))
print("Test5:", min_total_damage(10, 10, 100, 80, 25, 10, 30, 50))




def min_total_damage_real(nH, nL, hpH, hpL, atkH, atkL, dmgH, dmgL):
    pH = ceil(hpH / dmgH)
    pL = ceil(hpL / dmgL)
    INF = 10**18
    dp = [[INF]*(nL+1) for _ in range(nH+1)]
    dp[0][0] = 0
    for i in range(nH+1):
        for j in range(nL+1):
            if dp[i][j] == INF:
                continue
            aliveH = nH - i
            aliveL = nL - j
            if i < nH:
                dp[i+1][j] = min(
                    dp[i+1][j],
                    dp[i][j] + pH * (aliveH*atkH + aliveL*atkL)
                )
            if j < nL:
                dp[i][j+1] = min(
                    dp[i][j+1],
                    dp[i][j] + pL * (aliveH*atkH + aliveL*atkL)
                )
    return dp[nH][nL]


# 再测一次
print("Test1:", min_total_damage_real(2, 3, 100, 50, 20, 10, 30, 50))
print("Test2:", min_total_damage_real(2, 2, 150, 40, 40, 10, 30, 40))
print("Test3:", min_total_damage_real(3, 3, 120, 60, 10, 25, 30, 50))
print("Test4:", min_total_damage_real(2, 3, 100, 50, 20, 10, 30, 1000))
print("Test5:", min_total_damage_real(10, 10, 100, 80, 25, 10, 30, 50))




from math import ceil
INF = 10**18

def min_damage_3d_dp(nB, nM, nS,
                     hpB, hpM, hpS,
                     atkB, atkM, atkS,
                     dmgB, dmgM, dmgS):
    # 每类的“处理时间”(回合数) p 和 权重 w
    pB, pM, pS = ceil(hpB/dmgB), ceil(hpM/dmgM), ceil(hpS/dmgS)
    wB, wM, wS = atkB, atkM, atkS

    # dp 与 路径恢复
    dp = [[[INF]*(nS+1) for _ in range(nM+1)] for __ in range(nB+1)]
    prev = [[[None]*(nS+1) for _ in range(nM+1)] for __ in range(nB+1)]
    dp[0][0][0] = 0

    for i in range(nB+1):
        for j in range(nM+1):
            for k in range(nS+1):
                if dp[i][j][k] == INF: 
                    continue
                T = i*pB + j*pM + k*pS
                # 追加一只大
                if i < nB:
                    nd = dp[i][j][k] + wB * (T + pB)
                    if nd < dp[i+1][j][k]:
                        dp[i+1][j][k] = nd
                        prev[i+1][j][k] = (i,j,k,'B')
                # 追加一只中
                if j < nM:
                    nd = dp[i][j][k] + wM * (T + pM)
                    if nd < dp[i][j+1][k]:
                        dp[i][j+1][k] = nd
                        prev[i][j+1][k] = (i,j,k,'M')
                # 追加一只小
                if k < nS:
                    nd = dp[i][j][k] + wS * (T + pS)
                    if nd < dp[i][j][k+1]:
                        dp[i][j][k+1] = nd
                        prev[i][j][k+1] = (i,j,k,'S')

    # 结果与顺序恢复
    res = dp[nB][nM][nS]
    order = []
    cur = (nB, nM, nS)
    while cur != (0,0,0):
        pi, pj, pk, typ = prev[cur[0]][cur[1]][cur[2]]
        order.append(typ)
        cur = (pi, pj, pk)
    order.reverse()  # 从头到尾的击杀顺序（只给出类型序列）
    return res, order
print("min_damage_3d_dp: ", min_damage_3d_dp(2, 3, 3, 100, 50, 30, 20, 10, 5, 80, 15, 20))



"""
========================================================
🔥 坦克最优击毁策略问题：三种算法对比总结
========================================================

问题描述：
----------------------------------------
有若干敌方单位，每个敌人 i 拥有：
    - hp[i]    : 血量
    - atk[i]   : 每轮攻击力或炮击伤害
    - intv[i]  : 攻击间隔（离散版用）
    - dmg[i]   : 我方每轮对该敌造成的伤害
目标：
    决定击杀顺序，使我方总受伤最小。

核心模型公式（连续近似）：
    总受伤 ≈ ∑ atk[i] * C[i]
    其中 C[i] = 敌人 i 被击杀时的累计时间
    p[i] = ceil(hp[i] / dmg[i]) 为击杀所需时间

--------------------------------------------------------
【方法一】离散暴力模拟（精确版）
--------------------------------------------------------
思路：
    - 真实模拟每个敌人的炮击周期；
    - 若“击杀时刻 == 开火时刻”，那炮算伤害；
    - 穷举所有击杀顺序并模拟完整时间轴。
优点：
    ✅ 结果最精确（真实离散行为下的全局最优）
缺点：
    ❌ 复杂度指数级（O(N! * P)）
    ❌ 只能处理小规模 N ≤ 7
时间复杂度：
    O(N! × P)，其中 P 为总击杀轮数
适用场景：
    - 需要精确验证贪心/DP 误差；
    - 离散事件明显（“卡一炮”效应显著）。

--------------------------------------------------------
【方法二】贪心排序（Smith’s Rule）
--------------------------------------------------------
思路：
    - 近似假设敌人伤害为连续平均速率；
    - 计算威胁度 ratio = atk / p；
    - 按 ratio 从大到小排序击杀。
数学依据：
    Smith’s Rule（最小加权完成时间）
时间复杂度：
    O(N log N)
优点：
    ✅ 极快（排序一次即可）
    ✅ 与 DP 在连续模型下结果相同
缺点：
    ⚠️ 离散炮击下非精确，可能卡边界多吃一炮
适用场景：
    - 敌人数量大（N 上百上千）
    - 线性近似模型（攻击独立、连续）

--------------------------------------------------------
【方法三】动态规划（DP 背包模型）
--------------------------------------------------------
思路：
    - 基于连续线性模型；
    - 状态 dp[i][j][k] = 已击杀若干类型的最小受伤；
    - 枚举下一个击杀对象更新 dp。
时间复杂度：
    - 二类敌人：O(n_H * n_L)
    - 三类敌人：O(n_H * n_M * n_L)
优点：
    ✅ 连续模型下的精确解
    ✅ 能处理“多类别多数量”的组合问题
缺点：
    ❌ 若考虑离散时序，状态爆炸不可用
    ❌ 与贪心结果相同但计算更慢
适用场景：
    - 小类别多数量；
    - 需要验证贪心等价性的情况。

--------------------------------------------------------
三者关系总结：
--------------------------------------------------------
    - 连续线性模型下：贪心 = DP（结果完全一致）
    - 离散炮击模型下：二者均为近似解
    - 若存在“卡一炮”或敌人间交互 → 只能用暴力/搜索

    算法精度层次：
        离散暴力  >  DP = 贪心（连续假设下）

    算法复杂度层次：
        贪心 (O(N log N))  <<  DP (O(N^2)~O(N^3))  <<  暴力 (O(N!))

========================================================
"""




"""
========================================================
⚠️ 离散炮击模型中的贪心失效特例
========================================================
目标：
    展示在“离散开火 + 同刻那一炮也算伤害”的规则下，
    贪心算法（按平均速率 atk/p 排序）失效的反例。

--------------------------------------------------------
参数设定：
--------------------------------------------------------
敌人 A：
    攻击间隔 s_A = 3 秒 / 炮
    单炮伤害 a_A = 90
    我方击杀所需时间 p_A = 2.9 秒
敌人 B：
    攻击间隔 s_B = 1 秒 / 炮
    单炮伤害 a_B = 40
    我方击杀所需时间 p_B = 2.0 秒
规则：
    - 所有敌人从 t = 0 开始计时；
    - 首炮时刻为各自的 interval；
    - 若击杀时刻 == 开火时刻，则该炮算伤害（敌方先结算）。

--------------------------------------------------------
贪心策略（平均速率近似）：
--------------------------------------------------------
计算平均输出速率：
    r_A = a_A / s_A = 90 / 3 = 30
    r_B = a_B / s_B = 40 / 1 = 40
计算威胁度（单位击杀时间伤害）：
    ratio_A = r_A / p_A ≈ 30 / 2.9 ≈ 10.34
    ratio_B = r_B / p_B = 40 / 2.0 = 20.0
贪心判断：
    ratio_B > ratio_A → 应该“先打 B 后打 A”

--------------------------------------------------------
离散真实模拟过程：
--------------------------------------------------------
时间轴事件（t 单位为秒）

顺序 1：先打 B（贪心推荐）
----------------------------------------
  0.0 - 2.0 : 攻击 B
    - B 在 t=1,2 各开一炮（t=2 与击杀同刻 → 算伤害）
        → B 造成 40 + 40 = 80
    - A 的首炮在 t=3，还没到
  2.0 - 4.9 : 攻击 A
    - A 在 t=3 打出首炮 → +90
  ✅ 总受伤 = 80 + 90 = 170

顺序 2：先打 A
----------------------------------------
  0.0 - 2.9 : 攻击 A
    - A 首炮在 t=3，尚未打出 → 0
    - B 在 t=1,2 各打一炮 → +80
  2.9 - 4.9 : 攻击 B
    - B 在 t=3,4 各打一炮 → +80
  ✅ 总受伤 = 80 + 80 = 160

结果对比：
    先打 A：160
    先打 B：170
⇒ 实际最优顺序 = “先打 A 后打 B”
   与贪心预测顺序相反（贪心失效）。

--------------------------------------------------------
原因分析：
--------------------------------------------------------
- 平均速率 r = a / s 假设敌人输出是连续流动的；
- 实际离散开火时，若击杀时刻恰好踩在开火边界，
  会多吃一炮（或少吃一炮），造成 ±a_i 的跳变；
- 这种跳变破坏了“线性可交换”性质，使得
  ∑ atk_i * C_i 不再严格成立；
- 因此贪心和连续 DP 仅是近似解，非严格最优。

--------------------------------------------------------
总结：
--------------------------------------------------------
    贪心失效条件：
        - 攻击为离散周期事件；
        - 击杀时刻与开火时刻可能重合；
        - 规则：同刻那一炮算伤害。
    现象：
        - “卡一炮”效应：顺序改变导致多吃或少吃一炮；
        - 平均速率模型无法捕捉这种非线性跳变；
        - 需要离散仿真或记忆化搜索求真最优。

========================================================
"""
