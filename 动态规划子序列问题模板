# 难点：不连续问题
# 一旦涉及到子序列和最值，那几乎可以肯定，考察的是动态规划技巧，时间复杂度一般都是 O(n^2)。

一、两种思路

1、第一种思路模板是一个一维的 dp 数组：

int n = array.length;
int[] dp = new int[n];

for (int i = 1; i < n; i++) {
    for (int j = 0; j < i; j++) {
        dp[i] = 最值(dp[i], dp[j] + ...)
    }
}

比如我们写过的 
最长递增子序列 和 
最大子数组和 都是这个思路。

在这个思路中 dp 数组的定义是：
在子数组 arr[0..i] 中，以 arr[i] 结尾的子序列的长度是 dp[i]。


2、第二种思路模板是一个二维的 dp 数组：
n = len(arr)
dp = [[0]*n for _ in range(n)]

for i in range(n):
    for j in range(n):
        if arr[i] == arr[j]:
            dp[i][j] = dp[i][j] + ...
        else:
            # 计算最值
            dp[i][j] = min(...)

这种思路运用相对更多一些，尤其是涉及两个字符串/数组的子序列时，比如前文讲的 
最长公共子序列 和 
编辑距离；这种思路也可以用于只涉及一个字符串/数组的情景，比如本文讲的回文子序列问题。

2.1 涉及两个字符串/数组的场景，dp 数组的定义如下：
    在子数组 arr1[0..i] 和子数组 arr2[0..j] 中，我们要求的子序列长度为 dp[i][j]。

2.2 只涉及一个字符串/数组的场景，dp 数组的定义如下：
    在子数组 array[i..j] 中，我们要求的子序列的长度为 dp[i][j]。


例题：最长回文子序列
知道了子问题 dp[i+1][j-1] 的结果（s[i+1..j-1] 中最长回文子序列的长度），你是否能想办法算出 dp[i][j] 的值（s[i..j] 中，最长回文子序列的长度）呢？
可以！这取决于 s[i] 和 s[j] 的字符：
如果它俩相等，那么它俩加上 s[i+1..j-1] 中的最长回文子序列就是 s[i..j] 的最长回文子序列：
如果它俩不相等，说明它俩不可能同时出现在 s[i..j] 的最长回文子序列中，那么把它俩分别加入 s[i+1..j-1] 中，看看哪个子串产生的回文子序列更长即可：

"""
第一张图：
字符串为：['c', 'b', 'x', 'a', 'b', 'y', 'c']
           i   i+1             j-1   j

如果 s[i] == s[j]，那么 s[i..j] 的最长回文子序列长度可以由 dp[i+1][j-1] 转移过来，
也就是 dp[i][j] = dp[i+1][j-1] + 2。


第二张图：
字符串为：['a', 'b', 'x', 'a', 'b', 'y', 'b']
           i   i+1             j-1   j

如果 s[i] != s[j]，说明它们不能同时出现在同一个回文子序列中，
我们需要在 s[i+1..j] 和 s[i..j-1] 中选择一个较长的回文子序列：
即 dp[i][j] = max(dp[i+1][j], dp[i][j-1])

"""

if (s[i] == s[j])
    // 它俩一定在最长回文子序列中
    dp[i][j] = dp[i + 1][j - 1] + 2;
else
    // s[i+1..j] 和 s[i..j-1] 谁的回文子序列更长？
    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
    

为了保证每次计算 dp[i][j]，左下右方向的位置已经被计算出来，只能斜着遍历或者反着遍历：

🧭 那么遍历顺序就非常重要了！
❌ 错误遍历（i 从上往下）：

for i in range(n):
    for j in range(i, n):
        dp[i][j] = ... # 会依赖 dp[i+1][j]，但它还没算

→ 这样当你计算 dp[0][3] 时，dp[1][3] 还没有值，会出错！


✅ 正确遍历：从下往上、从左往右

for i in range(n-1, -1, -1):        # i 递减，从下往上
    for j in range(i, n):           # j 递增，从左到右
        dp[i][j] = ...

这个顺序保证了：
    当你计算 dp[i][j] 时：
        dp[i+1][j-1] 已经算过（左下）
        dp[i+1][j] 已经算过（下）
        dp[i][j-1] 已经算过（左）


为了保证每次计算 dp[i][j]，左下右方向的位置已经被计算出来，只能斜着遍历或者反着遍历：

# 反着
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        n = len(s)
        # dp 数组全部初始化为 0
        dp = [[0] * n for _ in range(n)]
        # base case
        for i in range(n):
            dp[i][i] = 1
        # 反着遍历保证正确的状态转移
        for i in range(n - 1, -1, -1):
            for j in range(i + 1, n):
                # 状态转移方程
                if s[i] == s[j]:
                    dp[i][j] = dp[i + 1][j - 1] + 2
                else:
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
        # 整个 s 的最长回文子串长度
        return dp[0][n - 1]

# 斜着
def longestPalindromeSubseq(s: str) -> int:
    n = len(s)
    dp = [[0] * n for _ in range(n)]

    # 初始化对角线：单个字符是回文，长度为 1
    for i in range(n):
        dp[i][i] = 1

    # 斜着填表：遍历子串长度
    for length in range(2, n + 1):  # 子串长度从2到n
        for i in range(n - length + 1):
            j = i + length - 1  # 右端点
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])

    return dp[0][n - 1]
