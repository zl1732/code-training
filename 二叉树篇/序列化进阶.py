"""
1. 如果你的序列化结果中不包含空指针的信息，且你只给出一种遍历顺序，那么你无法还原出唯一的一棵二叉树。

2. 如果你的序列化结果中不包含空指针的信息，且你会给出两种遍历顺序，分两种情况：

    2.1. 如果你给出的是前序和中序，或者后序和中序，那么你可以还原出唯一的一棵二叉树。
    2.2. 如果你给出前序和后序，那么你无法还原出唯一的一棵二叉树。

3. 如果你的序列化结果中包含空指针的信息，且你只给出一种遍历顺序，也要分两种情况：
    3.1. 如果你给出的是前序或者后序，那么你可以还原出唯一的一棵二叉树。
    3.2. 如果你给出的是中序，那么你无法还原出唯一的一棵二叉树。

    
树 A：
  1
   \
    2

树 B：
  2
 /
1


我们分别写出中序遍历（含空指针）：

树 A：

Null, 1, Null, 2, Null


树 B：

Null, 1, Null, 2, Null


因为中序遍历记录的是：

    左子树访问顺序；
    根；
    右子树访问顺序。

但中序遍历中无法知道“当前根节点”对应的子树范围在哪里”。
即使你加上了“空节点”占位，也只是说明“某个节点的左子树为空”，但你不知道这个“空”属于哪一层的节点。


📘 5. 对比一下：前序或后序为什么可以

前序遍历顺序：

    根 → 左子树 → 右子树
    后序遍历顺序：
    左子树 → 右子树 → 根

这两种遍历都显式包含“根节点的访问次序”。
因此，当你加入空指针时，它们的结构信息是完备的。
"""